#!/usr/bin/env python3

import os , sys , json , arrow , subprocess

CONFIG = os.path.expanduser( '~/.config/commuting/config' )

STIBCACHE = os.path.expanduser( '~/.cache/stib' )
STIBCONFIG = os.path.expanduser( '~/.config/stib/config' )

HALT = STIBCACHE + '/{}'
LINE = HALT + '/{}'
TIME = LINE + '/{}'

log = lambda *x , **y : print( *x , **y , file = sys.stderr )

with open( CONFIG ) as _config :
    config = json.load( _config )

with open( STIBCONFIG ) as _config :
    stibconfig = json.load( _config )

geolocation = json.loads( subprocess.check_output( [ 'memoize' , '3600' , 'geolocation.fetch' ] ).decode( ) )

pt = frozenset( ( args[0] , args[1] ) for road in config.values( ) for path in road['paths'] for T , *args in
        path if T in 'BTM' )

def grab ( halt , line ) :

    try :

        return sorted( map( arrow.get , os.listdir( LINE.format( halt , line ) ) ) )

    except FileNotFoundError :

        log( 'no data for' , halt , line )

        return [ ]

def _repr ( path ) :

    return ' -- '.join( T if T == 'W' else args[1] for T , *args in path )

stib = { }

for halt , line in pt :

    if halt not in stibconfig or line not in stibconfig[halt] :

        log( 'warning: stib is not configured to fetch' , halt , line )

    stib[ ( halt , line ) ] = grab( halt , line )

def allroutes ( ) :

    for name , road in config.items( ) :

        for path in road['paths'] :

            for route in routes( path ) :

                yield name , route

def routes ( path , leave = None , total = 0 , prev = ( ) ) :

    if not path :

        yield leave , total , prev

        return

    T , *args = path[0]

    if T == 'W' :

        duration = args[0]

        yield from routes( path[1:] , leave , total + duration , prev + (
            path[0], ) )

    else :

        halt , line , duration = args

        if leave is None :

            for timestamp in stib[ ( halt , line ) ] :

                yield from routes( path[1:] , timestamp.replace( seconds =-
                    total) , total + duration , prev + ( path[0], ) )
        else :

            for timestamp in stib[ ( halt , line ) ] :

                # not sure if best option

                waiting = timestamp.datetime.timestamp( ) - leave.datetime.timestamp( ) - total

                if waiting < 0 : continue

                yield from routes( path[1:] , leave , total + waiting +
                        duration , prev + ( path[0], ) )

NOW = arrow.now( )

myroutes = [ ]

for name , route in allroutes ( ) :

    _leave , _total , _path = route

    if _leave is None : _leave = NOW

    if _leave < NOW : continue

    _arrival = _leave.replace( seconds = +_total )

    myroutes.append( ( name , _path , _leave , _arrival ) )

myroutes = sorted( myroutes , key = lambda x : ( x[0] , x[3] , x[2] , x[1] ) )

def myfilter ( name ) :

    for key , value in config[name]['geolocation'].items( ) :

        if not key in geolocation or geolocation[key] != value :

            return False

    return True

for name , _path , _leave , _arrival in myroutes :

    if not myfilter( name ) : continue

    leave = _leave.humanize( NOW )
    arrival = _arrival.humanize( NOW )
    total = _arrival.humanize( _leave )[3:] # remove "in " prefix
    path = _repr( _path )

    log( name , leave , arrival , path , total )

