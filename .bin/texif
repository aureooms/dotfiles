#!/usr/bin/env node

require('babel-core/register');
require('babel-polyfill');
const { iter , next , list , map } = require('@aureooms/js-itertools');
const { ll1 } = require('@aureooms/js-grammar');
const stream = require('@aureooms/js-stream');

function* tokens ( string ) {

  let i = 0 ;
  let n = string.length ;

  let buffer = '';

  while ( i < n ) {
    const c = string[i] ;
    if ( c === '\\' ) {

      // read command

      let cmd = c ;
      outer : while ( ++i < n ) {
	let d = string[i];
	switch ( d ) {
	  case ' '  :
	  case '\t' :
	  case '\n' :
	  case '%'  :
	  case '\\'  :
	  case '{'  :
	  case '}'  :
	  case ',' :
	    if (cmd === '') {
	      cmd = d ;
	      ++i;
	    }
	    break outer ;
	  default:
	    cmd += d;
	    break;
	}
      }

      if ( cmd.substr(0,3) === '\\if' )  {
	if ( buffer !== '' ) {
	  yield [ 'text' , buffer ] ;
	  buffer = '';
	}
	yield [ 'ifcmd' , cmd ] ;
      }

      else if (cmd.substr(cmd.length-5, 5) === 'false' ) {
	if ( buffer !== '' ) {
	  yield [ 'text' , buffer ] ;
	  buffer = '';
	}
	yield [ 'falsecmd' , cmd ] ;
      }

      else if (cmd.substr(cmd.length-4, 4) === 'true' ) {
	if ( buffer !== '' ) {
	  yield [ 'text' , buffer ] ;
	  buffer = '';
	}
	yield [ 'truecmd' , cmd ] ;
      }

      else if ( cmd === '\\newif' )  {
	if ( buffer !== '' ) {
	  yield [ 'text' , buffer ] ;
	  buffer = '';
	}
	yield [ 'newif' , cmd ] ;
      }

      else if ( cmd === '\\else' )  {
	if ( buffer !== '' ) {
	  yield [ 'text' , buffer ] ;
	  buffer = '';
	}
	yield [ 'else' , cmd ] ;
      }

      else if ( cmd === '\\fi' )  {
	if ( buffer !== '' ) {
	  yield [ 'text' , buffer ] ;
	  buffer = '';
	}
	yield [ 'fi' , cmd ] ;
      }

      else {
	buffer += cmd ;
      }

    }
    else {
      buffer += c ;
      ++i;
    }
  }
  if ( buffer !== '' ) {
    yield [ 'text' , buffer ] ;
    buffer = '';
  }
}

const G = [
  [ // blocks : 0
    [ 1 , 0 ] , // 0.0
    [ ] , // 0.1
  ] ,
  [ // block : 1
    [ 'text' ] , // 1.0
    [ 'newif' , 'ifcmd' ] , // 1.1
    [ 'ifcmd' , 0 , 2 ] , // 1.2
    [ 'falsecmd' ] , // 1.3
    [ 'truecmd' ] , // 1.4
    [ 'othercmd' ] , // 1.5
  ] ,
  [ // endif : 2
    [ 'else' , 0 , 'fi' ] , // 2.0
    [ 'fi' ] , // 2.1
  ] ,
] ;

function match ( token , terminal ) {
  if ( token !== terminal ) throw new Error(`Tokens do not match: '${token}' !== '${terminal}'`)
}

const devnull = { 'write' : buffer => true } ;

function shake ( out , tree , it , variables ) {

  var token, buffer;

  switch ( tree.nonterminal ) {
    case 0:
      switch ( tree.production.id ) {
	case 0:
	  shake( out , tree.children[0] , it , variables ) ;
	  shake( out , tree.children[1] , it , variables ) ;
	  break;
	case 1:
	  break;
      }
      break;
    case 1:
      switch ( tree.production.id ) {
	case 0:
	  [ token , buffer ] = next(it);
	  match(token, 'text');
	  out.write(buffer);
	  break;
	case 1:
	  [ token , buffer ] = next(it);
	  match(token, 'newif');
	  [ token , buffer ] = next(it);
	  match(token, 'ifcmd');
	  break;
	case 2:
	  [ token , buffer ] = next(it);
	  match(token, 'ifcmd');
	  const variable = buffer.substr(3);
	  const flag = variables.get(variable);
	  shake(flag ? out : devnull, tree.children[1] , it , variables ) ;
	  switch ( tree.children[2].production.id ) {
	    case 0:
	      [ token , buffer ] = next(it);
	      match(token, 'else');
	      shake(flag ? devnull : out, tree.children[2].children[1] , it , variables ) ;
	    case 1:
	      [ token , buffer ] = next(it);
	      match(token, 'fi');
	      break;
	  }
	  break;
	case 3:
	  [ token , buffer ] = next(it);
	  match(token, 'falsecmd');
	  variables.set(buffer.substring(1,buffer.length-5), false);
	  break;
	case 4:
	  [ token , buffer ] = next(it);
	  match(token, 'truecmd');
	  variables.set(buffer.substring(1,buffer.length-4), true);
	  break;
	case 5:
	  [ token , buffer ] = next(it);
	  match(token, 'othercmd');
	  out.write(buffer);
	  break;
      }
      break;
    case 2:
      throw new Error('Should never reach case 2');
  }

}


const table = ll1.compile(0, G);

let content = '';
process.stdin.resume();
process.stdin.on('data', function(buf) { content += buf.toString(); });
process.stdin.on('end', function() {
    // your code here
    const mytokens = list(tokens(content));
    //for ( const token of mytokens ) console.log(token) ;
    const mystream = stream.fromiterable(map(([a,b]) => a, mytokens));
    const ast = ll1.parse(0, G, table, mystream);
    //console.log(JSON.stringify(ast));
    shake(process.stdout, ast.children[0], iter(mytokens), new Map());
});
