#!/usr/bin/env python3

DEFAULT_FRAME_RATE = 44100 # Hz
DEFAULT_FREQUENCY = 440 # Hz
DEFAULT_DURATION = 200 # milliseconds
DEFAULT_VOLUME = 0.5 # 0 <= v <= 1

AMPLITUDE_MAX = 2**15-1 # max int16

import json
import argparse
import numpy as np
from math import ceil
from pydub import AudioSegment
from collections import ChainMap

def normalize ( sig , amplitude = AMPLITUDE_MAX ) :
    return np.int16(sig/np.max(np.abs(sig)) * amplitude)

def note ( config , frame_rate = DEFAULT_FRAME_RATE ) :

    duration = config['duration']
    frequency = config['frequency']
    fadeout = config['fadeout']
    volume = config['volume']
    amplitude = AMPLITUDE_MAX * volume

    frames = int(ceil(frame_rate*duration/1000))

    sig = np.cos((2*np.pi*frequency/frame_rate)*np.arange(frames))

    if fadeout == 'linear':
        sig *= np.linspace(1,0,num=frames)

    sig = normalize(sig, amplitude=amplitude)

    return AudioSegment(
        # raw audio data (bytes)
        data=sig.tobytes(),

        # 2 byte (16 bit) samples
        sample_width=2,

        # 44.1 kHz frame rate
        frame_rate=frame_rate,

        # mono
        channels=1
    )


def patternitem ( config ) :

    if config['type'] == 'loop' :

        for i in range(config['repeat']) :

            yield from patternlist(config)

    elif config['type'] == 'note' :

        yield note(config)

    elif config['type'] == 'silence' :

        yield AudioSegment.silent(duration=config['duration'])

    else :

        raise Exception('unknown pattern item type `{}`'.format(config['type']))


def patternlist ( config ) :

    for item in config['pattern']:
        yield from patternitem(ChainMap(item, config))


def overlaypattern( audio , config ) :

    # generate overlaying pattern while avoiding wasting resources

    ms = len( audio )

    if ms == 0 :
        return audio

    pattern = AudioSegment.empty()

    for part in patternitem(config) :

        pattern += part

        if len(pattern) >= ms :
            break

    return audio * pattern # * overlays


def main ( ) :

    parser = argparse.ArgumentParser(description='Overlay beeper pattern on top of an existing audio file.')

    parser.add_argument('pattern', type=str, help='pattern JSON file')
    parser.add_argument('input', type=str, help='input filename')
    parser.add_argument('output', type=str, help='output filename')

    args = parser.parse_args()

    with open(args.pattern) as fd :
        config = json.load(fd)

    audio = AudioSegment.from_file( args.input )

    mix = overlaypattern( audio , config )

    mix.export(args.output)

if __name__ == '__main__' :
    main()
