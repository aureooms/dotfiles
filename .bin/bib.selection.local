#!/usr/bin/env python3
# vi:syntax=python

import arrow

prompt = ['dmenu_center', '--rest', '-i', '-t', '-p', 'bib', '-sb', '#8080ff', '-l', '10']
querystring = 'ext:bib'
sortby = 'mtime'
ascending = False

def formatentry(entry):

    items = [
        'ENTRYTYPE' ,
        'ID' ,
        'author' ,
        'title' ,
        'year' ,
        'month' ,
        'journal' ,
        'booktitle' ,
        'volume' ,
        'publisher' ,
        'keyword' ,
        'pages' ,
        'abstract' ,
        'comments' ,
    ]

    formatarray = map(lambda x: '{'+x+'}', filter(entry.__contains__ , items))

    return ' -- '.join(formatarray).format(**entry).replace('\n', ' ').replace('\r', '')

import os
import sys
import logging
# recoll
from recoll import recoll, rclextract
# bibtex
import bibtexparser
from bibtexparser.bwriter import BibTexWriter
from bibtexparser.bibdatabase import BibDatabase
# dmenu
from subprocess import check_output, call

log = logging.getLogger(__name__)
log.setLevel(logging.INFO)

handler = logging.StreamHandler(sys.stdout)
handler.setLevel(logging.INFO)
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
handler.setFormatter(formatter)
log.addHandler(handler)

# read all local bib files (surprisingly fast)

db = recoll.connect()

query = db.query()

if sortby:
    query.sortby(sortby, ascending=ascending)

n = query.execute(querystring)

log.info('{} results'.format(n))

docs = list(query)

db = BibDatabase()
db.entries = [ ]

for doc in docs:

    log.info('parsing %s', doc.url)

    if doc.ipath:
        extractor = rclextract.Extractor(doc)
        path = extractor.idoctofile(doc.ipath, doc.mimetype).decode()

    else:
        path = doc.url[7:]

    with open(path) as bibtex_file:
        bibtex_str = bibtex_file.read()

    bib_database = bibtexparser.loads(bibtex_str)
    db.entries += bib_database.entries

    if doc.ipath and path[:5] == '/tmp/':
        log.info('deleting {}'.format(path))
        # just in case someone screws up upstreams
        os.remove(path)

log.info('Found {} entries'.format(len(db.entries)))

# remove duplicates

unique = set(frozenset(entry.items()) for entry in db.entries)

log.info('Removed {} duplicate entries'.format(len(db.entries)-len(unique)))

db.entries = list(map(dict,unique))

log.info('Left with {} unique entries'.format(len(db.entries)))

# prompt with dmenu

def genline(i, entry, formatentry=formatentry):
    return formatentry(entry) + ' ' + str(i)

lines = sorted(genline(i, entry) for i, entry in enumerate(db.entries))

raw = '\n'.join(lines).encode()

try:
    result = check_output(prompt, input=raw)

except Exception as e:
    log.exception('dmenu failed')
    sys.exit(1)

# decode dmenu output

line = result.decode()[:-1]

try:

    i = int(line.split()[-1])

except Exception as e:
    log.exception('could not parse line number')
    sys.exit(2)

try:
    entry = db.entries[i]
except IndexError as e:
    log.exception('index not in range')
    sys.exit(3)

if genline(i, entry) != line:
    log.error('lines do not match')
    sys.exit(4)

# copy to clipboard

writer = BibTexWriter()

out = BibDatabase()
out.entries = [ entry ]

entry_text = writer.write(out)

print(entry_text)

raw = entry_text.encode()

check_output(['xsel', '-b'], input=raw)
