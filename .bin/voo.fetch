#!/usr/bin/env node

const puppeteer = require('puppeteer');
const fs = require('fs');
const spawn = require('child_process').spawn ;

const HOME = process.env['HOME'] ;
const CACHE = HOME + '/.cache/voo' ;
const CACHE_INFO = CACHE + '/info.json' ;

console.log('HOME', HOME);
console.log('CACHE', CACHE);
console.log('CACHE_INFO', CACHE_INFO);

//const URL_LOGIN = 'https://newmy.voo.be' ;
const URL_CONSUMPTION = 'https://newmy.voo.be/usage/internet';

const TYPE_UNKNOWN = 'unknown page' ;
const TYPE_LOGIN = 'login page' ;
const TYPE_LOGIN_ERROR = 'login error' ;
const TYPE_CONSUMPTION = 'consumption page' ;
const TYPE_TIMEOUT = 'timeout error' ;

const TIME_SECOND = 1000 ;
const TIME_MINUTE = TIME_SECOND * 60 ;
const TIME_HOUR = TIME_MINUTE * 60 ;
const TIME_HALF_HOUR = TIME_HOUR / 2 | 0 ;

//currently non polling, single fetch is done, polling is handled by shell script
//const POLL_RATE = TIME_HALF_HOUR ;
//const POLL_RATE = TIME_MINUTE ;
const READ_RATE = TIME_SECOND * 3 ;
const LOGIN_WAIT = TIME_MINUTE ;
const LOGIN_TIMEOUT = TIME_MINUTE ;

let lastlogin = 0 ;

const sleep = ms => {
	console.log(`sleeping for ${ms} ms`)
    return new Promise(resolve => setTimeout(resolve, ms));
} ;

function main ( browser ) {

	try {
		fs.mkdirSync(CACHE);
	}
	catch ( e ) {
		if (e && e.code !== 'EEXIST') {
			console.error(e);
			process.exit(67);
		}
	}

	// parse username and password
	const input = fs.readFileSync('/dev/stdin').toString().split('\n');

	switch (input.length) {
		case 0:
			console.log('Could not find username or password');
			process.exit(1);
			break;
		case 1:
			console.log('Could not find password');
			process.exit(2);
			break;
	}

	const username = input[0];
	const password = input[1];

	const options = {
		executablePath: '/usr/bin/chromium' ,
	} ;

	puppeteer.launch(options).then(async browser => {
		await poll(browser, username, password);
		await browser.close();
	});

}

async function poll ( browser , username , password ) {

	console.log( 'credentials' , username , password.replace(/./g, '*'));

	const page = await browser.newPage();

	//page.onError = function (msg, trace) {
		//console.log(msg);
		//trace.forEach(function(item) {
			//console.log('  ', item.file, ':', item.line);
		//});
	//};

	//while ( true ) { // NOT POLLING ATM
		//await load(page , username, password);
		//await sleep(POLL_RATE);
	//}
	return await load( page , username , password );

}

async function load ( page , username , password ) {

	await page.goto(URL_CONSUMPTION);

	while ( true ) {

		const _type = await type(page);
		console.log(_type);

		if (_type === TYPE_TIMEOUT || _type === TYPE_LOGIN_ERROR) return 32;

		else if (_type === TYPE_UNKNOWN) await sleep(READ_RATE);

		else if (_type === TYPE_LOGIN) {
			await login(page, username, password);
			await sleep(READ_RATE);
		}

		else {
			const data = await getinfo(page);
			write(data);
			return 0;
		}

	}

}

async function type ( page ) {

	const now = Date.now();
	if (lastlogin > 0 && now - lastlogin >= LOGIN_TIMEOUT) return TYPE_TIMEOUT;

	return await page.evaluate((lastlogin, LOGIN_WAIT, TYPE_LOGIN, TYPE_LOGIN_ERROR, TYPE_CONSUMPTION, TYPE_UNKNOWN) => {
		const now = Date.now();
		if ( now - lastlogin >= LOGIN_WAIT && document.getElementById('UserName') !== null ) return TYPE_LOGIN ;
		else if ( document.querySelector('.validation-summary-errors') !== null ) return TYPE_LOGIN_ERROR ;
		else if ( document.querySelector('.gauge > .label-current') !== null &&
			document.querySelector('.gauge > .label-max') !== null ) return TYPE_CONSUMPTION ;
		else return TYPE_UNKNOWN ;
	}, lastlogin, LOGIN_WAIT, TYPE_LOGIN, TYPE_LOGIN_ERROR, TYPE_CONSUMPTION, TYPE_UNKNOWN);

}

async function login (page, username, password) {

	lastlogin = Date.now();

	console.log( 'login' , username , password.replace(/./g, '*'));

	return await page.evaluate( (username, password) => {
		document.getElementById('UserName').value = username;
		document.getElementById('Password').value = password;
		document.getElementsByTagName('form')[0].submit();
	}, username, password);

}

async function getinfo ( page ) {

	const consumption = await page.evaluate(() => ({
		'current' : document.querySelector('.gauge .label-current').innerText ,
		'max'     : document.querySelector('.gauge .label-max').innerText
	}));

	const current_float = parseFloat(consumption.current.match(/^[0-9]*(,[0-9]*)?/)[0].replace(',', '.')) ;
	const max_float = parseFloat(consumption.max.match(/^[0-9]*(,[0-9]*)?/)[0].replace(',', '.')) ;

	const current_unit = consumption.current.match(/[a-zA-Z]*$/)[0];
	const max_unit = consumption.max.match(/[a-zA-Z]*$/)[0];

	const data = {
		'consumption' : {
			'current' : {
				'raw' : consumption.current ,
				'amount' : current_float ,
				'unit' : current_unit
			} ,
			'max' : {
				'raw' : consumption.max ,
				'amount' : max_float ,
				'unit' : max_unit
			}
		}
	} ;

	return data ;

}

function write ( data ) {

	const cache = JSON.stringify(data);

	console.log(cache) ;

	fs.writeFileSync(CACHE_INFO, cache);

}

main();
